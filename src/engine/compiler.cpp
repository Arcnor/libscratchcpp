// SPDX-License-Identifier: Apache-2.0

#include "compiler.h"
#include "engine.h"
#include <cassert>
#include <iostream>

using namespace libscratchcpp;
using namespace vm;

/*! Constructs Compiler. */
Compiler::Compiler(Engine *engine) :
    m_engine(engine)
{
    assert(engine);
}

/*! Compiles the script. Use bytecode() to read the generated bytecode. */
void Compiler::compile(std::shared_ptr<Block> topLevelBlock)
{
    m_bytecode.clear();
    m_procedurePrototype = nullptr;
    m_atomic = true;

    // Add start instruction
    addInstruction(OP_START);

    m_block = topLevelBlock;
    while (m_block) {
        size_t substacks = m_substackTree.size();

        if (m_block->compileFunction())
            m_block->compile(this);
        else
            std::cout << "warning: unsupported block: " << m_block->opcode() << std::endl;

        if (substacks != m_substackTree.size())
            continue;

        if (m_block)
            m_block = m_block->next();

        if (!m_block && !m_substackTree.empty())
            substackEnd();
    }

    // Add end instruction (halt)
    addInstruction(OP_HALT);
}

/*! Returns the generated bytecode. */
const std::vector<unsigned int> &Compiler::bytecode() const
{
    return m_bytecode;
}

/*! Returns the Engine. */
Engine *Compiler::engine() const
{
    return m_engine;
}

/*! Returns the list of constant input values. */
const std::vector<InputValue *> &Compiler::constInputValues() const
{
    return m_constValues;
}

/*! Returns the list of constant values. */
std::vector<Value> Compiler::constValues() const
{
    std::vector<Value> ret;
    for (auto value : m_constValues)
        ret.push_back(value->value());
    return ret;
}

/*! Returns the list of variables. */
const std::vector<Variable *> &Compiler::variables() const
{
    return m_variables;
}

/*! Returns the list of pointers to variable values. */
std::vector<Value *> Compiler::variablePtrs() const
{
    std::vector<Value *> ret;
    for (auto var : m_variables)
        ret.push_back(var->valuePtr());
    return ret;
}

/*! Returns the list of lists. */
const std::vector<List *> &Compiler::lists() const
{
    return m_lists;
}

/*! Adds an instruction to the bytecode. */
void Compiler::addInstruction(Opcode opcode, std::initializer_list<unsigned int> args)
{
    m_bytecode.push_back(opcode);
    for (auto arg : args)
        m_bytecode.push_back(arg);
}

/*! Compiles the given input and adds it to the bytecode. */
void Compiler::addInput(Input *input)
{
    if (!input) {
        addInstruction(OP_NULL);
        return;
    }
    switch (input->type()) {
        case Input::Type::Shadow:
            addInstruction(OP_CONST, { constIndex(input->primaryValue()) });
            break;

        case Input::Type::NoShadow: {
            auto previousBlock = m_block;
            m_block = input->valueBlock();
            assert(m_block);
            if (m_block->compileFunction())
                m_block->compile(this);
            else {
                std::cout << "warning: unsupported reporter block: " << m_block->opcode() << std::endl;
                addInstruction(OP_NULL);
            }
            m_block = previousBlock;
            break;
        }

        case Input::Type::ObscuredShadow: {
            auto previousBlock = m_block;
            m_block = input->valueBlock();
            if (m_block) {
                if (m_block->compileFunction())
                    m_block->compile(this);
                else {
                    std::cout << "warning: unsupported reporter block: " << m_block->opcode() << std::endl;
                    addInstruction(OP_NULL);
                }
            } else
                input->primaryValue()->compile(this);
            m_block = previousBlock;
            break;
        }
    }
}

/*! Compiles the given input (resolved by ID) and adds it to the bytecode. */
void Compiler::addInput(int id)
{
    addInput(input(id));
}

/*! Adds a function call to the bytecode (the OP_EXEC instruction). */
void Compiler::addFunctionCall(BlockFunc f)
{
    addInstruction(OP_EXEC, { m_engine->functionIndex(f) });
}

/*! Adds an argument to a procedure (custom block). */
void Compiler::addProcedureArg(std::string procCode, std::string argName)
{
    m_procedureArgs[procCode].push_back(argName);
}

/*! Jumps to the given substack. The second substack is used for example for the if/else block. */
void Compiler::moveToSubstack(std::shared_ptr<Block> substack1, std::shared_ptr<Block> substack2, SubstackType type)
{
    m_substackTree.push_back({ { m_block, substack2 }, type });
    m_block = substack1;
    if (!m_block)
        substackEnd();
}

/*! Jumps to the given substack. */
void Compiler::moveToSubstack(std::shared_ptr<Block> substack, SubstackType type)
{
    moveToSubstack(substack, nullptr, type);
}

/*!
 * Adds the vm::OP_BREAK_ATOMIC instruction at the end of the current loop.
 * This can be used for example in motion blocks.
 */
void Compiler::breakAtomicScript()
{
    m_atomic = false;
}

/*! Returns the input with the given ID. */
Input *Compiler::input(int id) const
{
    return m_block->findInputById(id);
}

/*! Returns the field with the given ID. */
Field *Compiler::field(int id) const
{
    return m_block->findFieldById(id);
}

/*! Returns the block in the given input. Same as input(id)->valueBlock(), but with a null pointer check. */
std::shared_ptr<Block> Compiler::inputBlock(int id) const
{
    auto in = input(id);
    return in ? in->valueBlock() : nullptr;
}

/*! Returns the index of the given variable. */
unsigned int Compiler::variableIndex(std::shared_ptr<IEntity> varEntity)
{
    auto var = dynamic_cast<Variable *>(varEntity.get());
    auto it = std::find(m_variables.begin(), m_variables.end(), var);
    if (it != m_variables.end())
        return it - m_variables.begin();
    m_variables.push_back(var);
    return m_variables.size() - 1;
}

/*! Returns the index of the given list. */
unsigned int Compiler::listIndex(std::shared_ptr<IEntity> listEntity)
{
    auto list = dynamic_cast<List *>(listEntity.get());
    auto it = std::find(m_lists.begin(), m_lists.end(), list);
    if (it != m_lists.end())
        return it - m_lists.begin();
    m_lists.push_back(list);
    return m_lists.size() - 1;
}

unsigned int Compiler::constIndex(InputValue *value)
{
    auto it = std::find(m_constValues.begin(), m_constValues.end(), value);
    if (it != m_constValues.end())
        return it - m_constValues.begin();
    m_constValues.push_back(value);
    return m_constValues.size() - 1;
}

/*! Returns the index of the procedure code of the given block. */
unsigned int Compiler::procedureIndex(std::string proc)
{
    auto it = std::find(m_procedures.begin(), m_procedures.end(), proc);
    if (it != m_procedures.end())
        return it - m_procedures.begin();
    m_procedures.push_back(proc);
    return m_procedures.size() - 1;
}

/*! Returns the index of the argument of the given procedure (custom block). */
long Compiler::procedureArgIndex(std::string procCode, std::string argName)
{
    if (m_procedureArgs.count(procCode) == 0) {
        std::cout << "warning: could not find custom block '" << procCode << "'" << std::endl;
        return -1;
    }
    const std::vector<std::string> args = m_procedureArgs[procCode];
    auto it = std::find(args.begin(), args.end(), argName);
    if (it != args.end())
        return it - args.begin();
    std::cout << "warning: could not find argument '" << argName << "' in custom block '" << procCode << "'" << std::endl;
    return -1;
}

void Compiler::substackEnd()
{
    auto parent = m_substackTree.back();
    switch (parent.second) {
        case SubstackType::Loop:
            if (!m_atomic) {
                addInstruction(OP_BREAK_ATOMIC);
                m_atomic = true;
            }
            addInstruction(OP_LOOP_END);
            break;
        case SubstackType::IfStatement:
            if (parent.first.second) {
                addInstruction(OP_ELSE);
                m_block = parent.first.second;
                m_substackTree[m_substackTree.size() - 1].first.second = nullptr;
                return;
            } else
                addInstruction(OP_ENDIF);
            break;
    }
    m_block = parent.first.first->next();
    m_substackTree.pop_back();
    if (!m_block && !m_substackTree.empty())
        substackEnd();
}

/*! Returns the prototype of the current custom block. */
BlockPrototype *Compiler::procedurePrototype() const
{
    return m_procedurePrototype;
}

/*! Sets the prototype of the current custom block. */
void Compiler::setProcedurePrototype(BlockPrototype *prototype)
{
    m_procedurePrototype = prototype;
}

/*! Returns the list of custom block prototypes. */
const std::vector<std::string> &Compiler::procedures() const
{
    return m_procedures;
}

/*! Returns the current block. */
const std::shared_ptr<Block> &Compiler::block() const
{
    return m_block;
}
